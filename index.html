<!DOCTYPE html>
<html lang="en">
<head>
    <!-- [Previous head content remains exactly the same] -->
</head>
<body>
    <!-- [Previous body content remains exactly the same until the script section] -->

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // [Previous DOM element declarations remain the same]

            // Process CSV data - separates Nginx and non-Nginx data with improved column handling
            function processCSV(csvData) {
                const lines = csvData.split('\n').filter(line => line.trim());
                if (lines.length < 2) throw new Error('CSV must have header row and at least one data row');
                
                // Detect delimiter (tab or comma)
                let delimiter = '\t';
                let headers = lines[0].split(delimiter).map(h => h.trim());
                if (headers.length < 3) {
                    delimiter = ',';
                    headers = lines[0].split(delimiter).map(h => h.trim());
                }

                // Log all found columns for debugging
                console.log("Found columns:", headers);

                // Define all possible column names we might look for
                const columnMapping = {
                    severity: ['severity', 'vulnerability severity', 'risk', 'risk level'],
                    vulnId: ['vulnid', 'vuln id', 'cve', 'cveid', 'cve id'],
                    repositoryName: ['repositoryname', 'repository name', 'repository', 'repo', 'servicename'],
                    packageName: ['packagename', 'package name', 'package'],
                    category: ['category'],
                    version: ['version', 'installed version', 'current version'],
                    fixedVersion: ['fixedversion', 'fixed version', 'patched version'],
                    vendor: ['vendor'],
                    fixStatus: ['fixstatus', 'fix status']
                };

                // Find column indices for all possible columns
                const columnIndices = {};
                const foundColumns = [];
                const missingRequiredColumns = [];

                for (const [key, possibleNames] of Object.entries(columnMapping)) {
                    const index = findColumnIndex(headers, possibleNames);
                    if (index !== -1) {
                        columnIndices[key] = index;
                        foundColumns.push(`${key} (found as "${headers[index]}")`);
                    } else if (key === 'severity' || key === 'vulnId' || key === 'repositoryName') {
                        missingRequiredColumns.push(key);
                    }
                }

                // Show found and missing columns in status
                if (missingRequiredColumns.length > 0) {
                    const errorMsg = `Missing required columns: ${missingRequiredColumns.join(', ')}.\n` +
                                    `Found columns: ${headers.join(', ')}\n` +
                                    `Matched columns: ${foundColumns.join(', ')}`;
                    throw new Error(errorMsg);
                }

                const nonNginxData = [];
                const nginxData = [];
                const uniqueCves = new Set();
                const uniqueServices = new Set();
                const nginxUniqueCves = new Set();
                const nginxUniqueServices = new Set();
                
                for (let i = 1; i < lines.length; i++) {
                    if (!lines[i].trim()) continue;
                    
                    const values = lines[i].split(delimiter);
                    const severity = values[columnIndices.severity]?.trim();
                    const vulnId = values[columnIndices.vulnId]?.trim();
                    const repositoryName = values[columnIndices.repositoryName]?.trim();
                    const packageName = columnIndices.packageName !== undefined ? values[columnIndices.packageName]?.trim() : 'N/A';
                    const category = columnIndices.category !== undefined ? values[columnIndices.category]?.trim() : 'N/A';
                    const version = columnIndices.version !== undefined ? values[columnIndices.version]?.trim() : 'N/A';
                    const fixedVersion = columnIndices.fixedVersion !== undefined ? values[columnIndices.fixedVersion]?.trim() : 'N/A';
                    const vendor = columnIndices.vendor !== undefined ? values[columnIndices.vendor]?.trim() : 'N/A';
                    const fixStatus = columnIndices.fixStatus !== undefined ? values[columnIndices.fixStatus]?.trim() : 'N/A';
                    
                    if (!severity || !vulnId || !repositoryName) continue;
                    
                    // Extract service name from repositoryName (after last slash)
                    let serviceName = 'Unknown Service';
                    if (repositoryName.includes('/')) {
                        serviceName = repositoryName.split('/').pop();
                    } else {
                        serviceName = repositoryName;
                    }
                    
                    const item = {
                        serviceName: serviceName,
                        cveId: vulnId,
                        severity: severity,
                        packageName: packageName,
                        category: category,
                        version: version,
                        fixedVersion: fixedVersion,
                        vendor: vendor,
                        fixStatus: fixStatus,
                        fullRepositoryName: repositoryName
                    };
                    
                    // Separate Nginx and non-Nginx data
                    if (repositoryName.toLowerCase().includes('nginx')) {
                        nginxData.push(item);
                        nginxUniqueCves.add(vulnId);
                        nginxUniqueServices.add(serviceName);
                    } else {
                        nonNginxData.push(item);
                        uniqueCves.add(vulnId);
                        uniqueServices.add(serviceName);
                    }
                }
                
                return { nonNginxData, nginxData };
            }
            
            // Helper function to find column index
            function findColumnIndex(headers, possibleNames) {
                const lowerHeaders = headers.map(h => h.toLowerCase());
                for (const name of possibleNames) {
                    const index = lowerHeaders.indexOf(name.toLowerCase());
                    if (index !== -1) return index;
                }
                return -1;
            }

            // [Rest of the code remains exactly the same]
        });
    </script>
</body>
</html>
